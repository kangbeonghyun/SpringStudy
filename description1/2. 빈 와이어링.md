# Spring in Action

## 2 빈 와이어링

* 와이어링: 객체 간의 이러한 연관관계 형성 작업(DI)

### 2.1 스프링 설정 옵션

* 스프링 컨테이너는 애플리케이션 내에서의 빈 생성 및 DI를 통해 객체 사이의 관계 조정에 책임을 짐

  * 어떤 빈을 생성하고 어떻게 역을지를 스프링에게 말해주는 것은 개발자.

* 그러한 빈 와이어링 명세서의 세가지 방법(와이어링 메커니즘)

  * 먕시적인 설정이 적을수록 좋고(자동이 좋음), 명시적인 빈 설정을 해야할 때(유지보수하지 않는 소스 코드에 대한 빈을 설정할 때와 같은)에는 타입 세이프를 보장하고 더욱 강력한 자바 컨피그가 좋음.  XML 네임스페이스 기능이 자바 컨피그에 없을 경우는 XML 사용

  1. XML에서의 명시적 설정
  2. 자바에서 명시적 설정
  3. 내제되어 있는 빈을 찾아 자동으로 와이어링

### 2.2 자동으로 빈 와이어링(오토와이어링)

* 스프링의 오토 와이어링 2가지 방법(모두 사용하면 좋다)
  1. 컴포넌트 스캐닝: 스프링은 Application Context에서 생성되는 빈을 자동으로 발견한다
  2. 오토와이어링: 스프링은 자동으로 빈 의존성을 충족시킨다.

#### 2.2.1 발견 가능한 빈 만들기

```java
public interface CD{
  void play();
}
```

```java
@Component
public class SgtPeppers implements CD {
  private String title = "앨범 타이틀";
  private String artist = "비틀즈";
  
  public void play() {
    sout("play");
  }
}
```

* @Component 애너테이션을 통해 해당 클래스가 컴포넌트 클래스임을 나타내고, 그 클래스를 빈으로 만들어야 함을 스프링에 단서로 제공한다.(SgtPeppers 빈을 명시적으로 설정할 필요는 없다)

* 근데 컴포넌트 스캐닝이 있어야 스프링이 이 클래스를 찾을 수 있다.

  ```java
  //이건 자바 컨피그, 근데 여기서 명시적 빈 설정 안한다는 것이 중요한 것.(컴포넌트 스캐닝하기 때문)
  @Configuration
  @ComponentScan
  public class CDConfig {
    
  }
  ```

  * 결과적으로, 이렇게만 설정해도 그 패키지와 하위 패키지를 스캔하고, @Component로 애너테이트된 클래스를 찾는다. 그리고 빈을 만든다

  ```java
  //XML 컨피그
  ,,,
  //<context: component-scan>이라는 컨텍스트 네임스페이스 요소 사용.
  <context: component-scan base-package="soundsystem"/>
  ,,,
  ```

  * <context: component-scan> 요소에는 @ComponentScan을 사용할 때 애트리뷰트 값과 사용할 애트리뷰트를 미러링하는 하위 요소가 있다.(그래서 자바 컨피그를 주로 선호함..?)

* 컴포넌트 스캐닝 작업을 테스트하기 위해서 스프링 ApplicationContext 생성과 CD 빈이 생성되었는지 테스트

  * SpringJunit4ClassRunner: 테스트 시작 시 자동으로 생성되는 스프링 ApplicationContext를 가짐
  * @ContextConfiguration: CDConfig 클래스를 통해서 설정을 로드
    * CDConfig는 컴포넌트스캔 애너테이션이 붙어있으므로 ApplicationContext는 CD 빈을 포함함.
  * @Autowired: CD 빈을 테스트로 주입(CD 타입 프로퍼티를 가짐)

```java
@RunWith(SpringJunit4ClassRunner.class)
@ContextConfiguration(classes=CDConfig.class)
public class CDTest {
  @Autowired
  private CD cd;
  
  @Test
  public void cd는_널이면안된다() {
    assertNotNull(cd);
  }
}
```

* 결과적으로 @ComponentScan 한 줄로 많은 빈을 자동으로 생성할 수 있다.(feat. @Component)

#### 2.2.2 컴포넌트 스캔된 빈 명명하기

* 스프링 ApplicationContext에서 모든 빈은 ID가 주어짐.
  * 따로 명시되어 있지 않으면 클래스 명의 첫글자를 소문자로 바꾼 ID를 가짐
* 빈에 원하는 ID를 주는 방법
  1. **@Component("원하는 이름")**
  2. @Named("원하는 이름")// 스프링이 아닌 자바 종속객체에 정의, @Component필요없음, 근데 이거 별로 사용안함.

#### 2.2.3 컴포넌트 스캐닝을 위한 베이스 패키지 세팅

* 원하는 베이스 패키지를 명시적으로 설정하는 방법
  * 명시적으로 베이스 패키지를 설정하는 이유는 애플리케이션 코드와 설정 코드를 분리하여 보관하려고.
* @ComponentScan("패키지이름")//좀 더 명확히는,  @ComponentScan(basePackages="패키지이름")
  * 여러개도 가능
  * String으로 관리되므로 패키지 이름이 변경되면 바꿔줘야 한다. 따라서 @ComponentScan에서 옵션으로 제공하는 패키지 내의 클래스나 인터페이스를 사용할 수 있다.
    * ComponentScan(basePackageClasses={CD.class, DVD.class})
    * 마커 인터페이스를 사용하면 리팩토링이 쉽도록 인터페이스에 대한 레퍼런스만 가지게 되고, 실제 애플리케이션 코드에 대한 레퍼런스를 사용하지 않을 수 있다.(*이건 잘 모르겠는데..)*

* 애플리케이션의 모든 객체가 의존성이 없고, 혼자이면 컴포넌트 스캔으로 충분하지만, 대게 그렇지 않다. 따라서 의존성을 가지고 컴포넌트 스캔된 빈을 묶이 위한 방법이 필요하다.(=오토 와이어링)

#### 2.2.4 오토와이어링 되는 빈의 애너테이션

* 오토와이어링: 스프링이 빈의 요구 사황과 매칭되는 ApplicationContext상에서 다른 빈을 찾아 빈 간의 의존성을 자동으로 만족시키도록 하는 수단.

  * @Autowired 애너테이션을 사용

  ```java
  @Component
  public class CDPlayer implements MediaPlayer { 
   private CD cd;
   
    @Autowired
    public CDPlayer(CD cd){
      this.cd=cd;
    }
    public void play() {
      cd.play();
    }
  }
  ```

  * 생성자에 @Autowired 가 걸려있는데, 이때  @Autowired는 스프링이 CDPlayer 빈을 생성할 때 생성자를 통해서 인스턴스화 하고 CD에 대입 가능한 빈을 전달해줌.(CDPlayer 빈과 CD빈을 와이어링)
    * 꼭 생성자가만이 아니고 프로퍼티 세터 등 모든 메서드에 사용된다.
  * 스프링은 메소드 파라미터에 의존성을 가지는데, 한개의 빈이 일치하면 그 빈은 와이어링 된다. 만약 매칭되는 빈이 없다면 스프링은 ApplicationContext가 생성될 때 예외를 발생시킨다
    * @Autowired(required=false)로 예외를 피할 수 있다. 즉 매칭되는 빈이 없으면 와이어링 되지 않은 상태로 남겨진다. 근데 이후 와이어링 되지 않은 객체를 사용할 때에 NPE가 발생할 수 있으므로 주의해야 한다. 

* @Inject: 스프링 기반의 애너테이션을 사용하기 힘든 경우 자바 종속객체에 정의되어 있는 @Inject를 이용할 수 있다.



