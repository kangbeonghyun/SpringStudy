# Spring in Action

## 1.1 자바 개발 간소화

* 스프링의 핵심 = 자바 개발의 간소화, 이를 위한 4가지 전략
  1. POJO를 이용한 가볍고 비침투적 개발(클래스, 인터페이스, API를 코드에 직접 나타내지 않는 방법, 복잡성 분리)
  2. DI와 인터페이스 지향을 통한 느슨한 결합도
  3. 애스펙트와 공통 규약을 통한 선언적 프로그래밍
  4. 애스펙트와 템플릿을 통한 반복적인 코드 제거

### 1.1.1 POJO의 힘- POJO 지향 개발을 통해 어떻게 침투적 개발을 최소화 할 수 있는 지

* POJO의 예

  ```java
  package com.habuma.spring;
  
  public class HelloWorldBean {
    public String sayHello() {
      return "hello";
    }
  }
  ```

* 위 POJO에 스프링이 힘을 실어 주는 방법은 DI를 활용한 조립이다.

### 1.1.2 종속객체 주입(DI)

* 애플리케이션에 두 개 이상의 클래스가 서로 협력하여 비즈니스 로직을 수행하는데, 이때 각 객체는 협력하는 객체에 대한 레퍼런스를 얻을 책임이 있다. 
  * 이 때 결합도가 높아지고 테스트하기 힘든 코드가 만들어 질 수 있다. - 즉 결합이 있으면 그 코드가 수행다 될 때 까지 기다려야 함
* 결합도가 높은 코드 - 테스트와 재활용이 어렵고, 오류 하나 수정시 다른 오류를 발생시킬 위험이 있음.
* **DI를 이용하면 객체는 객체를 조율하는 제 3자에 의해 생성 시점에 종속객체가 부여된다.(결합도를 낮춤)**
  * 객체는 스스로 종속객체를 생성하거나 얻지 않는다.

```java
//결합도가 높은 코드
public class HorseKnight implements Knight {
  private RescueQuest quest;
  public HorseKnigt() {
    this.quest = new RescueQuest(); // 강한 결합
  }
}

//결합도가 낮은 생성자 주입, 즉 생성 시점에 주입 - 느슨한 결합도
//즉 자신이 퀘스트를 결정하는게 아니라, 생성 시점에 생성자 인자에 부여됨.
public class HorseKnight implements Knight {
  private Quest quest;//인터페이스
  public HorseKnigt(Quest quest) {//RescueQuest 주입, Quest는 인터페이스로, 다른 구현타입이 와도 된다.
    this.quest = quest;
  }
}
```

* 위와 같이 HorseKnight가 Quest의 특정 구현체에 결합되지 않는다.

* 어떤 객체가 자신이 필요로 하는 종속객체를 인터페이스를 통해서만 알고 있다면, 사용 객체 쪽에서 아무런 변경없이 종속객체를 다른 구현체로 바꾼다.

  * mock객체를 이용해 모의 구현체를 이용하여 HorseKnight를 쉽게 테스트 할 수 있다.

  ```java
  @Test
  public void Test() {
    Quest mockquest = mock(Quest.class);
    HorseKnight knight=new HorseKnight(mockquest);//생성자를 통한 mock 주입
    ,,,
  }
  ```

* HorseKnight에 어떤 Quest를 부여할 지를 어떻게 지정할까- **와이어링**

  * 와이어링: 애플리케이션 컴포넌트 간의 관계를 정하는 것
    1.  XML을 활용한 빈 와이어링

  ```xml
  <?xml version="1.0" encoding=UTF-8"?>
    ,,,
  <bean id="knight" class="com.springinaction.knight.HorseKnight"> // 빈 선언
    <constructor-arg ref="quest" /> //아래의 원정 빈 주입, HorseKnight는 생성되면서 레퍼런스를 DragonQuest 빈에게 넘겨주며 생성자의 인자가 된다,
  </bean>
  
  <bean id="quest" class="com.springinaction.knight.DragonQuest"> // 빈 선언
    <constructor-arg value="#{T(System).out}" /> //생성하면서 System.out을 DragonQuest의 생성자에 넘긴다.
  </bean>
  ```

  2. 자바 코드를 이용한 빈 와이어링

     ```java
     @Configuration
     public class KnightConfig {
       @Bean
       public Knight knight() {
         return new HorseKnight(quest());
       }
       
       @Bean
       public Quest quest() {
         return new Dragonquest(System.out);
       }
     }
     ```

  * 물론 위의 코드와 같이 DI를 했을 때 의존적인 부분이 있지만. 어떤 Quest가 주어질지, 그 Quest가 어디서로 부터 올지는 모른다.(몰라도 되게 된다) 스프링만 안다.

* ApplicationContext: 빈에 관한 정의들을 바탕으로 빈 들을 엮어 줌.

  * 객체의 생성과 와이어링을 책임.
  * ClassPathXmlApplicationContext(): 스프링 컨텍스트 구현체 중 하나로, 애플리케이션의 클래스패스에 있는 하나 이상의 XML 파일에서 스프링 컨텍스트를 로드.

  ```java
  public class Main {
    public static void main(String[] args) throw Exception{
      ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext("META-INF/spring/knights.xml");//knights.xml를 기반으로 스프링 어플리케이션 컨텍스트 생성
      
      Knight knight=context.getBean(Knight.class); //컨텍스트를 사용하여 빈 얻기
      knight.blablamethod(); 
      context.close();
    }
  }
  //이 클래스는 기사가 어떤 유형의 quest를 수행하는지 알지 못한다.knights.xml만 안다.
  ```

### 1.1.3 애스팩트 적용 - 시스템 내부의 관심사들을 서로 분리

* 애스팩트 지향 프로그래밍은 애플리케이션 전체에 걸쳐 사용되는 기능을 재사용할 수 있는 컴포넌트에 담는다

* 횡단 관심사(cross-cutting concerns): 로깅, 트랜잭션 관리, 보안같은 시스템 서비스, 이것들에 대한 관심사가 여러 컴포넌트에 퍼지면 2가지 차원에서 복잡해짐

  1. 여러 컴포넌트에 중복되어 나타남. - 또한 이 횡단 관심사의 구현을 변경해야 하는 경우 중복되어 있으니 다 일일히 바꿔줘야 함
  2. 본연의 기능과 관련없는 코드로 인해 지저분해진다.

* AOP는 시스템 서비스를 모듈화 해서 컴포넌트에 선언적으로 적용한다. AOP를 이용해 시스템 서비스에 대해서는 전혀 알지 못하지만, 본연의 관심사에 집중하는 컴포넌트를 만들 수 있다.= POJO를 단순화 한다.

  ```java
  public class HorseKnight implements Knight {
    private Quest quest;
    private Minstrel minstrel;//횡단 관심사
    public HorseKnigt(Quest quest, Minstrel minstrel) {
      this.quest = quest;
      this.minstrel=minstrel;
    }
    
    public void doQuest() throw Exception {
      minstrel.singBeforeQuest();
      quest.doing();
      minstrel.singAfterQuest();
     }
  }
  ```

  * 근데, 이렇게 되면 기사가 음유시인에 대해 알아야 한다. 또한 이를 위해 HorseKnight 생성자 주입에 음유시인을 넣어야 한다. -> minstrel을 애스펙트로 바꾸려면 스프링 설정 파일의 하나로 선언하기만 하면 된다.

  ```java
  ,,,
  <bean id="ministrel" class="com.springinaction.knights.Ministrel">//빈 선언
    <constructor-arg value="#T(System).out"/>
  </bean>
    
  //aop namespace
  <aop:config>
    <aop:aspect ref="ministrel"> // ministrel 빈 참조
      <aop:pointcut id="doing" expression="excution(**.doing(..))"/>//포인트 컷정의
      <aop:before pointcut-red="doing" method="singBeforeQuest"/> //비포 어드바이스
      <aop:after pointcut-red="doing" method="singAfterQuest"/> //애프터 어드바이스
    </aop:aspect>
  </aop:config>    
  ```

  * 알아야할 사실

  1. ministrel은 여전히 POJO라는 점 - ministrel이 스프링 애스펙트라는 것은 ministrel의 내용에는 전혀 없다. 스프링 컨텍스트에서 선언적으로 애스펙트가 된다.
  2. HorseKnight가 ministrel을 명시적으로 호출하지 않아도(몰라도) ministrel의 메소드가 적용된다.

### 1.1.4 스프링 템플릿을 통한 상투적인 코드 개선

* 예를 들어 jdbc 같은 경우 crud외에 연결, 예외처리, 정리작업 등 복잡하게 필요한데, JdbcTemplate을 사용해서 상투적인 코드를 캡슐화, 반복제거 할 수 있다.



